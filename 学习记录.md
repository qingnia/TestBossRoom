# 适配
1. 项目引用了navMesh库，2022版本已经内置到引擎，因此升级后要删掉库引用
2. auth库的2.4.0有bug，编辑器环境下profile检查会抛异常，导致编辑器环境不能使用lobby，仿照官方，降到2.3.1版本
# 参考文档
[知乎其他人经验 这个人的代码老旧，部分已经对不上](https://zhuanlan.zhihu.com/p/426092367)
# 语法
## inject
> 一知半解：网上看到的描述说这是种注入，实际使用效果更接近跨类共享数据

[Inject注入介绍](https://blog.csdn.net/qq_35531227/article/details/84839483)
## VContainer
> 看不懂
[VContainer](https://vcontainer.hadashikick.jp/resolving/gameobject-injection)
## readonly
> 声明后，可以在构造函数做一次赋值，之后就不能改变
## event 事件处理
```c#
//注册事件
/// <summary>
/// Server notification when a client requests a different lobby-seat, or locks in theiseat choice
/// </summary>
public event Action<ulong, int, bool> OnClientChangedSeat;
//响应事件
public void OnNetworkSpawn()
{
    if (!NetworkManager.Singleton.IsServer)
    {
        enabled = false;
    }
    else
    {
        NetworkManager.Singleton.OnClientDisconnectCallback +OnClientDisconnectCallback;
        networkCharSelection.OnClientChangedSeat += OnClientChangedSeat
        NetworkManager.Singleton.SceneManager.OnSceneEvent += OnSceneEvent;
    }
}
public void OnNetworkDespawn()
{
    if (NetworkManager.Singleton)
    {
        NetworkManager.Singleton.OnClientDisconnectCallback -OnClientDisconnectCallback;
        NetworkManager.Singleton.SceneManager.OnSceneEvent -= OnSceneEvent;
    }
    if (networkCharSelection)
    {
        networkCharSelection.OnClientChangedSeat -= OnClientChangedSeat;
    }
}
//触发事件
/// <summary>
/// RPC to notify the server that a client has chosen a seat.
/// </summary>
[ServerRpc(RequireOwnership = false)]
public void ChangeSeatServerRpc(ulong clientId, int seatIdx, bool lockedIn)
{
    OnClientChangedSeat?.Invoke(clientId, seatIdx, lockedIn);
}
```
# 初始化
```c#
// 在StartUp做游戏初始化，然后再到开始场景
// 切换场景不销毁的对象，都用了DontDestroyOnLoad
// NetworkManager.cs，声明并且注入了游戏状态机，游戏状态改变时调
// 
// 选人界面的networkCharSelection.LobbyPlayers存放着所有玩家在服务器的实例，用来做选人的校验和同步
```
## BossRoom
```c#
// OnLoadEventCompleted 这个事件会生成玩家
```
## Action
```c#
//BossRoom的协议包基类是ActionRequestData，定义了很多非必填字段，又根据flag做流量优化，如果字段是默认值，就算缺省
//游戏定义了一种资源类型要Action，列举了玩家行为，基本可以认为是同步包协议的定义
//发包函数
void SendInput(ActionRequestData action)
{
    ActionInputEvent?.Invoke(action);
    m_ServerCharacter.RecvDoActionServerRPC(action);
}
//组包发送
var data = new ActionRequestData();
PopulateSkillRequest(k_CachedHit[0].point, actionID, ref data);
SendInput(data);

//施放需要指定目标或范围指示器的技能，也一样被包装进Action，字段是ActionInput
//ArcherVolley里面引用的ClientAoeInpuf，就是个指示器
//实际上会生成一个GameObject在场景，挂脚本AoeActionInput控制
var actionPrototype = GameDataSource.Instance.GetActionPrototypeByID(m_ActionRequests[i].RequestedActionID);
if (actionPrototype.Config.ActionInput != null)
{
    //如果ActionInpuf不为空，就生成指示器
    var skillPlayer = Instantiate(actionPrototype.Config.ActionInput);
    //指示器的参数传了委托Action，sendInput，实际就是发包
    skillPlayer.Initiate(m_ServerCharacter, m_PhysicsWrapper.Transform.position, actionPrototype.ActionID, SendInput, FinishSkill);
    m_CurrentSkillInput = skillPlayer;
}
else
{
    PerformSkill(actionPrototype.ActionID, m_ActionRequests[i].TriggerStyle, m_ActionRequests[i].TargetId);
}
//鼠标操作
//IsPointerOverGameObject是unity很常用的方法，判断点击的是UI还是场景
if (!EventSystem.current.IsPointerOverGameObject() && m_CurrentSkillInput == null)
{
    //IsPointerOverGameObject() is a simple way to determine if the mouse is overUI element. If it is, we don't perform mouse input logic,
    //to model the button "blocking" mouse clicks from falling through ainteracting with the worl
    
    //鼠标输入右键按下是攻击
    if (Input.GetMouseButtonDown(1))
    {
        RequestAction(CharacterClass.Skill1.ActionID, SkillTriggerStyle.MouseClick);
    }
    //左键按下是选中目标，朝目标移动
    if (Input.GetMouseButtonDown(0))
    {
        RequestAction(GameDataSource.Instance.GeneralTargetActionPrototype.ActionISkillTriggerStyle.MouseClick);
    }
    //如果当前帧不是按下左键，但左键还没松开，就认为是控制移动
    else if (Input.GetMouseButton(0))
    {
        m_MoveRequest = true;
        --todo：fixUpdate里面通过射线检测更新目标点
    }
}

using Action = Unity.BossRoom.Gameplay.Actions.Action;
//DontDestroyOnLoad场景存了很多对象
//GameDataSource 里存行为列表
[Tooltip("All Action prototype scriptable objects should be slotted in here")]
[SerializeField]
private Action[] m_ActionPrototypes;
//用法
var actionPrototype = GameDataSource.Instance.GetActionPrototypeByID(m_ActionRequests[i].RequestedActionID);
if (actionPrototype.Config.ActionInput != null)
{
    var skillPlayer = Instantiate(actionPrototype.Config.ActionInput);
    skillPlayer.Initiate(m_ServerCharacter, m_PhysicsWrapper.Transform.position, actionPrototype.ActionID, SendInput, FinishSkill);
    m_CurrentSkillInput = skillPlayer;
}
else
{
    PerformSkill(actionPrototype.ActionID, m_ActionRequests[i].TriggerStyle, m_ActionRequests[i].TargetId);
}
```
## startup
# rpc
##
```c#
//分主机和客机，serverRpc默认只有主机能调用
//如果声明了RequireOwnership=false，客机也能用，如角色选择
        /// <summary>
        /// RPC to notify the server that a client has chosen a seat.
        /// </summary>
        [ServerRpc(RequireOwnership = false)]
        public void ChangeSeatServerRpc(ulong clientId, int seatIdx, bool lockedIn)
        {
            OnClientChangedSeat?.Invoke(clientId, seatIdx, lockedIn);
        }
```